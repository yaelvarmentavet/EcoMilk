<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd"
     xml:lang="en">
  <head>
    <title>Information Center for ARM</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <link type="text/css" rel="stylesheet" media="all" href="file://$TOOLKIT_DIR$/doc/infocenter/style/ewic.css" />
  </head>
  <body>
  <div id="topbanner"></div>
  <div id="titlebanner_small">
    <h2>Information Center for ARM</h2>
  </div>
  <div class="breadcrumb"><a href="$TOOLKIT_DIR$/doc/infocenter/index.ENU.html">Information Center for ARM</a> | EXAMPLES</div>
  <div class="mainblock">
   <h2>Example description</h2>

   <pre>  <!--Insert readme.txt-->
<span style="font-family: monospace;">
	USART Hyperterminal interrupt Example

	Example Description

This example provides a description of how to use the USART1 for STM32F051R8T6 devices
and USART2 STM32F072VBT6 devices with Transmit and Receive interrupts to communicate
with the hyperterminal.

First, the USART sends the TxBuffer to the hyperterminal and still waiting for
a string from the hyperterminal that you must enter.The string that you have entered
is stored in the RxBuffer array. The receive buffer have a RxBufferSize bytes as
maximum (the reception is stopped when this maximum receive value is reached).

The USART is configured as follow:
    - BaudRate = 9600 baud
    - Word Length = 8 Bits (7 data bit + 1 parity bit)
    - Two Stop Bit
    - Odd parity
    - Hardware flow control disabled (RTS and CTS signals)
    - Receive and transmit enabled

 note When the parity is enabled, the computed parity is inserted at the MSB
position of the transmitted data.


	Directory contents

  - USART/HyperTerminal_Interrupt/stm32f0xx_conf.h    Library Configuration file
  - USART/HyperTerminal_Interrupt/stm32f0xx_it.c      Interrupt handlers
  - USART/HyperTerminal_Interrupt/stm32f0xx_it.h      Interrupt handlers header file
  - USART/HyperTerminal_Interrupt/main.c              Main program
  - USART/HyperTerminal_Interrupt/main.h              Main program header file
  - USART/HyperTerminal_Interrupt/system_stm32f0xx.c  STM32F0xx system source file

 note The "system_stm32f0xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to meet user application requirements.
      To select different clock setup, use the "STM32F0xx_Clock_Configuration_VX.Y.Z.xls"
      provided with the AN4055 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F0xx devices.

  - This example has been tested with STMicroelectronics STM320518-EVAL and
    STM32072B-EVAL including respectively STM32F051R8T6 and STM32F072VBT6 devices
    and can be easily tailored to any other supported device and development board

  - STM320518-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN7 and PC serial port.
      - Make sure that JP3 is in position 5&lt;-&gt;6

  - STM32072B-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN10 and PC serial port.
      - Make sure that JP17 is in position 5&lt;-&gt;6

  - Hyperterminal configuration:
    - Word Length = 7 Bits
    - Two Stop Bit
    - Odd parity
    - BaudRate = 9600 baud
    - flow control: None


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F0xx_StdPeriph_Templates
 - Open your preferred toolchain
 - If the used device is STM32F051R8T6 choose STM32F051 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM320518_EVAL\stm320518_eval.c
 - If the used device is STM32F072VBT6 choose STM32F072 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM32072B_EVAL\stm32072b_eval.c
 - Rebuild all files and load your image into target memory
 - Run the example

***********************************************************************************

	USART Printf example

	Example Description

This example shows how to retarget the C library printf function to the USART.
This implementation output the printf message on the Hyperterminal using USART1
for STM32F051R8T6 devices and USART2 for STM32F072VBT6 devices.

The USARTx is configured as follow:
    - BaudRate = 115200 baud
    - Word Length = 8 Bits
    - One Stop Bit
    - No parity
    - Hardware flow control disabled (RTS and CTS signals)
    - Receive and transmit enabled


	Directory contents

  - USART/Printf/stm32f0xx_conf.h     Library Configuration file
  - USART/Printf/stm32f0xx_it.h       Interrupt handlers header file
  - USART/Printf/stm32f0xx_it.c       Interrupt handlers
  - USART/Printf/main.c               Main program
  - PWR/PWR_STANDBY/main.h            Header for main.c module
  - USART/Printf/system_stm32f0xx.c   STM32F0xx system source file

 note The "system_stm32f0xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to meet user application requirements.
      To select different clock setup, use the "STM32F0xx_Clock_Configuration_VX.Y.Z.xls"
      provided with the AN4055 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F0xx devices.

  - This example has been tested with STMicroelectronics STM320518-EVAL and
    STM32072B-EVAL including respectively STM32F051R8T6 and STM32F072VBT6 devices
    and can be easily tailored to any other supported device and development board

  - STM320518-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN7 and PC serial port.
  - STM32072B-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN10 and PC serial port.

  - Hyperterminal configuration:
    - Word Length = 8 Bits
    - One Stop Bit
    - No parity
    - BaudRate = 115200 baud
    - flow control: None


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F0xx_StdPeriph_Templates
 - Open your preferred toolchain
 - Select STM32F051 workspace
 - If the used device is STM32F051R8T6 choose STM32F051 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM320518_EVAL\stm320518_eval.c
 - If the used device is STM32F072VBT6 choose STM32F072 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM32072B_EVAL\stm32072b_eval.c
 - Rebuild all files and load your image into target memory
 - Run the example

 note Known Limitations
      This example retargets the C library printf() function to the Hyperterminal
      (C library I/O redirected).
      TrueSTUDIO Lite version does not support I/O redirection, and instead
      have do-nothing stubs compiled into the C runtime library.
      To use printf() with TrueSTUDIO Professional version, just include the
      TrueSTUDIO Minimal System calls file "syscalls.c" provided within the toolchain.
      It contains additional code to support printf() redirection.

***********************************************************************************

	USART AutoBaudRate Example

	Example Description

This example provides a description of how to use the Auto BaudRate capability
of the USART via the HyperTerminal.

First, the USART1(STM32F051R8T6 devices) or USART2(STM32F072VBT6 devices) is configured
to detect BaudRate automatically with StartBit Measurement Method (Any character
starting with a bit at 1 should be send to USART to detect Baud Rate).

After configuration, the USART waits until a data is received via HyperTerminal
to launch auto-detection of Baud Rate phase. The end of this phase is monitored
by ABRF flag.

The result of auto-detection is indicated by EVAL Board LEDs. If an error occurred
in Auto BaudRate phase ABRE flag is set and LED3 is turned on. If this phase is
completed successfully, LED2 is turned on and the received data is transmitted back
to the HyperTerminal.
You can repeat this procedure by changing the BaudRate on HyperTerminal side.

The USART is configured as follow:
    - BaudRate = 115200 baud (any value can be chosen)
    - Word Length = 8 Bits
    - One Stop Bit
    - No parity
    - Hardware flow control disabled (RTS and CTS signals)
    - Receive and transmit enabled


	Directory contents

  - USART/USART_AutoBaudRate/stm32f0xx_conf.h    Library Configuration file
  - USART/USART_AutoBaudRate/stm32f0xx_it.c      Interrupt handlers
  - USART/USART_AutoBaudRate/stm32f0xx_it.h      Interrupt handlers header file
  - USART/USART_AutoBaudRate/main.c              Main program
  - USART/USART_AutoBaudRate/main.h              Main program header file
  - USART/USART_AutoBaudRate/system_stm32f0xx.c  STM32F0xx system source file

 note The "system_stm32f0xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to meet user application requirements.
      To select different clock setup, use the "STM32F0xx_Clock_Configuration_VX.Y.Z.xls"
      provided with the AN4055 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F0xx devices.

  - This example has been tested with STMicroelectronics STM320518-EVAL and
    STM32072B-EVAL including respectively STM32F051R8T6 and STM32F072VBT6 devices
    and can be easily tailored to any other supported device and development board

  - STM320518-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN7 and PC serial port.
      - Make sure that JP3 is in position 5&lt;-&gt;6

  - STM32072B-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN10 and PC serial port.
      - Make sure that JP17 is in position 5&lt;-&gt;6

  - Hyperterminal configuration:
    - BaudRate = User can select any value
    - Word Length = 8 Bits
    - One Stop Bit
    - No parity
    - flow control: None


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F0xx_StdPeriph_Templates
 - Open your preferred toolchain
 - Select STM32F051 workspace
 - If the used device is STM32F051R8T6 choose STM32F051 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM320518_EVAL\stm320518_eval.c
 - If the used device is STM32F072VBT6 choose STM32F072 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM32072B_EVAL\stm32072b_eval.cc
 - Rebuild all files and load your image into target memory
 - Run the example

***********************************************************************************

	USART Communication Boards Data Exchange using DMA example

	Example Description

This example provides a small application in which joystick buttons are used
to trigger USART communications using DMA and though using USART firmware library.

- Hardware Description

To use this example, you need to load it on two STM32 boards (let's call them
Board A and Board B) then connect these two boards through USART lines and GND.

*------------------------------------------------------------------------------*
|                BOARD A                                BOARD B                |
|         ____________________                   ____________________          |
|        |                    |                 |                    |         |
|        |                    |                 |                    |         |
|        |     __________     |                 |     __________     |         |
|        |    |   USART  |____|TX_____________RX|____|   USART  |    |         |
|        |    |  Device1 |____|RX_____________TX|____|  Device2 |    |         |
|        |    |__________|    |                 |    |__________|    |         |
|        |                    |                 |                    |         |
|        |  O LD1             |                 |  O LD1             |         |
|        |  O LD2    Joystick |                 |  O LD2    Joystick |         |
|        |  O LD3        _    |                 |  O LD3        _    |         |
|        |  O LD4       |_|   |                 |  O LD4       |_|   |         |
|        |                    |                 |                    |         |
|        |             GND O--|-----------------|--O GND             |         |
|        |____________________|                 |____________________|         |
|                                                                              |
|                                                                              |
*------------------------------------------------------------------------------*

 note
- The connection between the pins should use a common Ground.

- Software Description

On Board A, at each joystick buttons press:
- The USART Board A sends the specific command to the USART Board B (the command
  contains the transaction code (CMD_RIGHT, CMD_LEFT, CMD_UP, CMD_DOWN or CMD_SEL)
  followed by the number of data to be transmitted (CMD_RIGHT_SIZE, CMD_LEFT_SIZE,
  CMD_UP_SIZE, CMD_DOWN_SIZE or CMD_SEL_SIZE)

- The USART Board B receives the command and sends the CMD_ACK command to the USART board A

- The USART Board A receives the CMD_ACK command and sends the number of bytes
  from TxBuffer to the USART Board B.

- The USART Board B compares the number of bytes received with the defined ones into
  his TxBuffer.

  Received data correctness is signaled by LED lightening and though as follow:
   - Joystick RIGHT and data correctly received ==> LD2, LD3 ON and LD4 OFF
   - Joystick LEFT and data correctly received  ==> LD4 ON, LD2 and LD3 are OFF
   - Joystick UP and data correctly received    ==> LD2 ON, LD3 and LD4 are OFF
   - Joystick DOWN and data correctly received  ==> LD3 ON, LD2 and LD4 are OFF
   - Joystick SEL and data correctly received   ==> LD2, LD3 and LD4 are ON

The steps described above can be also initiated and ensured by Board B.

In both boards(Board A or Board B), the data transfers is managed using the USART
Tx/Rx channels DMA requests.

The SysTick is configured to generate interrupt each 10ms. A dedicated counter
inside the SysTick ISR is used to toggle the LD1 each 100ms indicating that the
firmware is running.

A defined communication timeout is insuring that the application will not remain
stuck if the USART communication is corrupted.
You can adjust this timeout through the USER_TIMEOUT  define inside main.h file
depending on CPU frequency and application conditions (interrupts routines,
number of data to transfer, baudrate, CPU frequency...).

These operations can be repeated infinitely.


	Directory contents

  - USART/USART_TwoBoards/DataExchangeDMA/stm32f0xx_conf.h    Library Configuration file
  - USART/USART_TwoBoards/DataExchangeDMA/stm32f0xx_it.c      Interrupt handlers
  - USART/USART_TwoBoards/DataExchangeDMA/stm32f0xx_it.h      Interrupt handlers header file
  - USART/USART_TwoBoards/DataExchangeDMA/main.c              Main program
  - USART/USART_TwoBoards/DataExchangeDMA/main.h              Main program header file
  - USART/USART_TwoBoards/DataExchangeDMA/system_stm32f0xx.c  STM32F0xx system source file

 note The "system_stm32f0xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to meet user application requirements.
      To select different clock setup, use the "STM32F0xx_Clock_Configuration_VX.Y.Z.xls"
      provided with the AN4055 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F0xx devices.

  - This example has been tested with STMicroelectronics STM320518-EVAL and
    STM32072B-EVAL including respectively STM32F051R8T6 and STM32F072VBT6 devices
    and can be easily tailored to any other supported device and development board

  - STM320518-EVAL Set-up
    - Connect USART1 TX pin (PA.09) to USARTx RX pin
    - Connect USART1 RX pin (PA.10) to USARTx TX pin
    - Connect GND pins of two boards
    - JP3 should be in 5-6 position
  - STM32072B-EVAL Set-up
    - Connect USART2 TX pin (PD.05) to USARTx RX pin
    - Connect USART2 RX pin (PD.06) to USARTx TX pin
    - Connect GND pins of two boards
    - JP17 should be in 5-6 position


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F0xx_StdPeriph_Templates
 - Open your preferred toolchain
 - If the used device is STM32F051R8T6 choose STM32F051 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM320518_EVAL\stm320518_eval.c
 - If the used device is STM32F072VBT6 choose STM32F072 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM32072B_EVAL\stm32072b_eval.c
 - Rebuild all files and load your image into target memory
 - Run the example

***********************************************************************************

	USART Communication Boards Data Exchange using Interrupt example

	Example Description

This example provides a small application in which joystick buttons are used
to trigger USART communication using interrupts and though using USART firmware
library.

- Hardware Description

To use this example, you need to load it on two STM32F0xx boards (let's call them
Board A and Board B) then connect these two boards through UART lines and GND.

*------------------------------------------------------------------------------*
|                BOARD A                                BOARD B                |
|         ____________________                   ____________________          |
|        |                    |                 |                    |         |
|        |                    |                 |                    |         |
|        |     __________     |                 |     __________     |         |
|        |    |   USART  |____|TX_____________RX|____|   USART  |    |         |
|        |    |  Device1 |____|RX_____________TX|____|  Device2 |    |         |
|        |    |__________|    |                 |    |__________|    |         |
|        |                    |                 |                    |         |
|        |  O LD1             |                 |  O LD1             |         |
|        |  O LD2    Joystick |                 |  O LD2    Joystick |         |
|        |  O LD3        _    |                 |  O LD3        _    |         |
|        |  O LD4       |_|   |                 |  O LD4       |_|   |         |
|        |                    |                 |                    |         |
|        |             GND O--|-----------------|--O GND             |         |
|        |____________________|                 |____________________|         |
|                                                                              |
|                                                                              |
*------------------------------------------------------------------------------*

 note
- The connection between the pins should use a common Ground.

- Software Description

On Board A, at each joystick buttons press:
- The USART Board A sends the specific command to the USART Board B (the command
  contains the transaction code (CMD_RIGHT, CMD_LEFT, CMD_UP, CMD_DOWN or CMD_SEL)
  followed by the number of data to be transmitted (CMD_RIGHT_SIZE, CMD_LEFT_SIZE,
  CMD_UP_SIZE, CMD_DOWN_SIZE or CMD_SEL_SIZE)

- The USART Board B receives the command and sends the CMD_ACK command to the USART board A

- The USART Board A receives the CMD_ACK command and sends the number of bytes
  from TxBuffer to the USART Board B.

- The USART Board B compares the number of bytes received with the defined ones into
  his TxBuffer.

  Received data correctness is signaled by LED lightening and though as follow:
   - Joystick RIGHT and data correctly received ==> LD2, LD3 ON and LD4 OFF
   - Joystick LEFT and data correctly received  ==> LD4 ON, LD2 and LD3 are OFF
   - Joystick UP and data correctly received    ==> LD2 ON, LD3 and LD4 are OFF
   - Joystick DOWN and data correctly received  ==> LD3 ON, LD2 and LD4 are OFF
   - Joystick SEL and data correctly received   ==> LD2, LD3 and LD4 are ON

The steps described above can be also initiated and ensured by Board B.

In both boards(Board A or Board B), the data transfers is managed using USARTx_IRQHandler
in stm32f0xx_it.c file when USARTx is used.

The SysTick is configured to generate interrupt each 10ms. A dedicated counter
inside the SysTick ISR is used to toggle the LD1 each 100ms indicating that the
firmware is running.
A defined communication timeout is insuring that the application will not remain
stuck if the USART communication is corrupted.
You can adjust this timeout through the USER_TIMEOUT  define inside main.h file
depending on CPU frequency and application conditions (interrupts routines,
number of data to transfer, baudrate, CPU frequency...).

These operations can be repeated infinitely.


	Directory contents

  - USART/USART_TwoBoards/DataExchangeInterrupt/stm32f0xx_conf.h    Library Configuration file
  - USART/USART_TwoBoards/DataExchangeInterrupt/stm32f0xx_it.c      Interrupt handlers
  - USART/USART_TwoBoards/DataExchangeInterrupt/stm32f0xx_it.h      Interrupt handlers header file
  - USART/USART_TwoBoards/DataExchangeInterrupt/main.c              Main program
  - USART/USART_TwoBoards/DataExchangeInterrupt/main.h              Main program header file
  - USART/USART_TwoBoards/DataExchangeInterrupt/system_stm32f0xx.c  STM32F0xx system source file

 note The "system_stm32f0xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to meet user application requirements.
      To select different clock setup, use the "STM32F0xx_Clock_Configuration_VX.Y.Z.xls"
      provided with the AN4055 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F0xx devices.

  - This example has been tested with STMicroelectronics STM320518-EVAL and
    STM32072B-EVAL including respectively STM32F051R8T6 and STM32F072VBT6 devices
    and can be easily tailored to any other supported device and development board

  - STM320518-EVAL Set-up
    - Connect USART1 TX pin (PA.09) to USARTx RX pin
    - Connect USART1 RX pin (PA.10) to USARTx TX pin
    - Connect GND pins of two boards
    - JP3 should be in 5-6 position

  - STM32072B-EVAL Set-up
    - Connect USART2 TX pin (PD.05) to USARTx RX pin
    - Connect USART2 RX pin (PD.06) to USARTx TX pin
    - Connect GND pins of two boards
    - JP17 should be in 5-6 position


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F0xx_StdPeriph_Templates
 - Open your preferred toolchain
 - If the used device is STM32F051R8T6 choose STM32F051 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM320518_EVAL\stm320518_eval.c
 - If the used device is STM32F072VBT6 choose STM32F072 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM32072B_EVAL\stm32072b_eval.c
 - Rebuild all files and load your image into target memory
 - Run the example

***********************************************************************************

	USART WakeUp from Stop mode Example

	Example Description

This example provides a description of how to use the WakeUp from STOP mode capability
of the USART via the hyperterminal.

First, the USART1(STM32F051R8T6 devices) or USART2(STM32F072VBT6 devices) is configured
to WakeUp from STOP with StartBitMethod(when any data is received on RX line).
After configuration, the MCU enters STOP mode and waits to be waken.
When a string is sent to USART via the hyperterminal, the MCU WakeUp from stop,
restore the system clock configuration and configures the systick to toggle LED's.
The LED's toggling is used to indicate that the MCU is Waken Up from stop.

The USART is configured as follow:
    - BaudRate = 115200 baud
    - Word Length = 8 Bits
    - One Stop Bit
    - No parity
    - Hardware flow control disabled (RTS and CTS signals)
    - Receive and transmit enabled


	Directory contents

  - USART/USART_WakeUpFromStop/stm32f0xx_conf.h    Library Configuration file
  - USART/USART_WakeUpFromStop/stm32f0xx_it.c      Interrupt handlers
  - USART/USART_WakeUpFromStop/stm32f0xx_it.h      Interrupt handlers header file
  - USART/USART_WakeUpFromStop/main.c              Main program
  - USART/USART_WakeUpFromStop/main.h              Main program header file
  - USART/USART_WakeUpFromStop/system_stm32f0xx.c  STM32F0xx system source file

 note The "system_stm32f0xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to meet user application requirements.
      To select different clock setup, use the "STM32F0xx_Clock_Configuration_VX.Y.Z.xls"
      provided with the AN4055 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F0xx devices.

  - This example has been tested with STMicroelectronics STM320518-EVAL and
    STM32072B-EVAL including respectively STM32F051R8T6 and STM32F072VBT6 devices
    and can be easily tailored to any other supported device and development board

  - STM320518-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN7 and PC serial port.
      - Make sure that JP3 is in position 5&lt;-&gt;6

  - STM32072B-EVAL Set-up
      - Connect a null-modem female/female RS232 cable between the DB9 connector
        CN10 and PC serial port.
      - Make sure that JP17 is in position 5&lt;-&gt;6

  - Hyperterminal configuration:
    - BaudRate = 115200 baud
    - Word Length = 8 Bits
    - One Stop Bit
    - No parity
    - flow control: None


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F0xx_StdPeriph_Templates
 - Open your preferred toolchain
 - If the used device is STM32F051R8T6 choose STM32F051 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM320518_EVAL\stm320518_eval.c
 - If the used device is STM32F072VBT6 choose STM32F072 project
    - Add the following files to the project source list
       - Utilities\STM32_EVAL\STM32072B_EVAL\stm32072b_eval.c
 - Rebuild all files and load your image into target memory
 - Run the example
   </span>
</pre>
  </div>
  </body>
</html>

